// Copyright 2015 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package state

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/juju/errors"
	"github.com/juju/names"
	jujutxn "github.com/juju/txn"
	"gopkg.in/juju/charm.v5"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
	"gopkg.in/mgo.v2/txn"

	"github.com/juju/juju/process"
)

// TODO(ericsnow) Implement persistence using a TXN abstraction (used
// in the business logic) with ops factories available from the
// persistence layer.

type procsPersistenceBase interface {
	// One populates doc with the document corresponding to the given
	// ID. Missing documents result in errors.NotFound.
	One(collName, id string, doc interface{}) error
	// All populates docs with the list of the documents corresponding
	// to the provided query.
	All(collName string, query, docs interface{}) error
	// Run runs the transaction generated by the provided factory
	// function. It may be retried several times.
	Run(transactions jujutxn.TransactionSource) error
}

type statePersistence struct {
	st *State
}

// One implements procsPersistenceBase.
func (sp statePersistence) One(collName, id string, doc interface{}) error {
	coll, closeColl := sp.st.getCollection(collName)
	defer closeColl()

	err := coll.FindId(id).One(doc)
	if err == mgo.ErrNotFound {
		return errors.NotFoundf(id)
	}
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}

// All implements procsPersistenceBase.
func (sp statePersistence) All(collName string, query, docs interface{}) error {
	coll, closeColl := sp.st.getCollection(collName)
	defer closeColl()

	if err := coll.FindId(query).All(docs); err != nil {
		return errors.Trace(err)
	}
	return nil
}

// Run implements procsPersistenceBase.
func (sp statePersistence) Run(transactions jujutxn.TransactionSource) error {
	if err := sp.st.run(transactions); err != nil {
		return errors.Trace(err)
	}
	return nil
}

type procsPersistence struct {
	st    procsPersistenceBase
	charm names.CharmTag
	unit  names.UnitTag
}

func newProcsPersistence(st procsPersistenceBase, charm *names.CharmTag, unit *names.UnitTag) *procsPersistence {
	pp := &procsPersistence{
		st: st,
	}
	if charm != nil {
		pp.charm = *charm
	}
	if unit != nil {
		pp.unit = *unit
	}
	return pp
}

func (pp procsPersistence) indexDefinitionDocs(ids []string) (map[interface{}]ProcessDefinitionDoc, error) {
	var docs []ProcessDefinitionDoc
	//query := bson.M{"_id": bson.M{"$in": ids}}
	query := bson.M{"$in": ids}
	if err := pp.all(query, &docs); err != nil {
		return nil, errors.Trace(err)
	}
	indexed := make(map[interface{}]ProcessDefinitionDoc)
	for _, doc := range docs {
		indexed[doc.DocID] = doc
	}
	return indexed, nil
}

// EnsureDefinitions checks persistence to see if records for the
// definitions are already there. If not then they are added. If so then
// they are checked to be sure they match those provided. The lists of
// names for those that already exist and that don't match are returned.
func (pp procsPersistence) EnsureDefinitions(definitions ...charm.Process) ([]string, []string, error) {
	var found []string
	var mismatched []string

	if len(definitions) == 0 {
		return found, mismatched, nil
	}

	var ids []string
	var ops []txn.Op
	for _, definition := range definitions {
		ids = append(ids, pp.definitionID(definition.Name))
		ops = append(ops, pp.newInsertDefinitionOp(definition))
	}
	buildTxn := func(attempt int) ([]txn.Op, error) {
		if attempt > 0 {
			// The last attempt aborted so clear out any ops that failed
			// the DocMissing assertion and try again.
			indexed, err := pp.indexDefinitionDocs(ids)
			if err != nil {
				return nil, errors.Trace(err)
			}

			var okOps []txn.Op
			for _, op := range ops {
				if existing, ok := indexed[op.Id]; !ok {
					okOps = append(okOps, op)
				} else { // Otherwise the op is dropped.
					id := fmt.Sprintf("%s", op.Id)
					found = append(found, id)
					definition, ok := op.Insert.(*ProcessDefinitionDoc)
					if !ok {
						return nil, errors.Errorf("inserting invalid type %T", op.Insert)
					}
					if !reflect.DeepEqual(definition, &existing) {
						mismatched = append(mismatched, id)
					}
				}
			}
			if len(okOps) == 0 {
				return nil, jujutxn.ErrNoOperations
			}
			ops = okOps
		}
		return ops, nil
	}
	if err := pp.st.Run(buildTxn); err != nil {
		return nil, nil, errors.Trace(err)
	}

	return found, mismatched, nil
}

// Insert adds records for the process to persistence. If the process
// is already there then false gets returned (true if inserted).
// Existing records are not checked for consistency.
func (pp procsPersistence) Insert(info process.Info) (bool, error) {
	var okay bool
	var ops []txn.Op
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	// TODO(ericsnow) Add pp.newEnsureDefinitionOp(info.Process)?
	ops = append(ops, pp.newInsertProcessOps(info)...)
	buildTxn := func(attempt int) ([]txn.Op, error) {
		if attempt > 0 {
			// One of the records already exists.
			okay = false
			return nil, jujutxn.ErrNoOperations
		}
		okay = true
		return ops, nil
	}
	if err := pp.st.Run(buildTxn); err != nil {
		return false, errors.Trace(err)
	}
	return okay, nil
}

// SetStatus updates the raw status for the identified process in
// persistence. The return value corresponds to whether or not the
// record was found in persistence. Any other problem results in
// an error. The process is not checked for inconsistent records.
func (pp procsPersistence) SetStatus(id string, status process.Status) (bool, error) {
	var found bool
	var ops []txn.Op
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	ops = append(ops, pp.newSetRawStatusOps(id, status)...)
	buildTxn := func(attempt int) ([]txn.Op, error) {
		if attempt > 0 {
			_, err := pp.proc(id)
			if errors.IsNotFound(err) {
				found = false
				return nil, jujutxn.ErrNoOperations
			} else if err != nil {
				return nil, errors.Trace(err)
			}
			// We ignore the request since the proc is dying.
			// TODO(ericsnow) Ensure that procDoc.Status != state.Alive?
			return nil, jujutxn.ErrNoOperations
		}
		found = true
		return ops, nil
	}
	if err := pp.st.Run(buildTxn); err != nil {
		return false, errors.Trace(err)
	}
	return found, nil
}

// List builds the list of processes found in persistence which match
// the provided IDs. The lists of IDs with missing records is also
// returned. Inconsistent records result in errors.NotValid.
func (pp procsPersistence) List(ids ...string) ([]process.Info, []string, error) {
	var missing []string

	// TODO(ericsnow) Ensure that the unit is Alive?
	// TODO(ericsnow) fix race that exists between the 3 calls
	definitionDocs, err := pp.definitions(ids)
	if err != nil {
		return nil, nil, errors.Trace(err)
	}
	launchDocs, err := pp.launches(ids)
	if err != nil {
		return nil, nil, errors.Trace(err)
	}
	procDocs, err := pp.procs(ids)
	if err != nil {
		return nil, nil, errors.Trace(err)
	}

	var results []process.Info
	for _, id := range ids {
		proc, missingCount := pp.extractProc(id, definitionDocs, launchDocs, procDocs)
		if missingCount > 0 {
			if missingCount < 7 {
				return nil, nil, errors.Errorf("found inconsistent records for process %q", id)
			}
			missing = append(missing, id)
			continue
		}
		results = append(results, *proc)
	}
	return results, missing, nil
}

func (pp procsPersistence) extractProc(id string, definitionDocs map[string]ProcessDefinitionDoc, launchDocs map[string]ProcessLaunchDoc, procDocs map[string]ProcessDoc) (*process.Info, int) {
	missing := 0
	name, _ := process.ParseID(id)
	definitionDoc, ok := definitionDocs[name]
	if !ok {
		missing += 1
	}
	launchDoc, ok := launchDocs[id]
	if !ok {
		missing += 2
	}
	procDoc, ok := procDocs[id]
	if !ok {
		missing += 4
	}
	if missing > 0 {
		return nil, missing
	}

	doc := processInfoDoc{
		definition: definitionDoc,
		launch:     launchDoc,
		proc:       procDoc,
	}
	info := doc.info()
	return &info, 0
}

// ListAll builds the list of all processes found in persistence.
// Inconsistent records result in errors.NotValid.
func (pp procsPersistence) ListAll() ([]process.Info, error) {
	// TODO(ericsnow) Ensure that the unit is Alive?
	// TODO(ericsnow) fix race that exists between the 3 calls
	definitionDocs, err := pp.allDefinitions()
	if err != nil {
		return nil, errors.Trace(err)
	}
	launchDocs, err := pp.allLaunches()
	if err != nil {
		return nil, errors.Trace(err)
	}
	procDocs, err := pp.allProcs()
	if err != nil {
		return nil, errors.Trace(err)
	}

	if len(launchDocs) > len(procDocs) {
		return nil, errors.Errorf("found inconsistent records (extra launch docs)")
	}

	var results []process.Info
	for id := range procDocs {
		proc, missingCount := pp.extractProc(id, definitionDocs, launchDocs, procDocs)
		if missingCount > 0 {
			return nil, errors.Errorf("found inconsistent records for process %q", id)
		}
		results = append(results, *proc)
	}
	for name, doc := range definitionDocs {
		matched := false
		for _, proc := range results {
			if name == proc.Name {
				matched = true
				break
			}
		}
		if !matched {
			results = append(results, process.Info{
				Process: doc.definition(),
			})
		}
	}
	return results, nil
}

// TODO(ericsnow) Add procs to state/cleanup.go.

// TODO(ericsnow) How to ensure they are completely removed from state?

// Remove removes all records associated with the identified process
// from persistence. Also returned is whether or not the process was
// found. If the records for the process are not consistent then
// errors.NotValid is returned.
func (pp procsPersistence) Remove(id string) (bool, error) {
	var found bool
	var ops []txn.Op
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	ops = append(ops, pp.newRemoveProcessOps(id)...)
	buildTxn := func(attempt int) ([]txn.Op, error) {
		if attempt > 0 {
			okay, err := pp.checkRecords(id)
			if err != nil {
				return nil, errors.Trace(err)
			}
			// If okay is true, it must be dying.
			found = okay
			return nil, jujutxn.ErrNoOperations
		}
		found = true
		return ops, nil
	}
	if err := pp.st.Run(buildTxn); err != nil {
		return false, errors.Trace(err)
	}
	return found, nil
}

func (pp procsPersistence) checkRecords(id string) (bool, error) {
	missing := 0
	_, err := pp.definition(id)
	if errors.IsNotFound(err) {
		missing += 1
	} else if err != nil {
		return false, errors.Trace(err)
	}
	_, err = pp.launch(id)
	if errors.IsNotFound(err) {
		missing += 2
	} else if err != nil {
		return false, errors.Trace(err)
	}
	_, err = pp.proc(id)
	if errors.IsNotFound(err) {
		missing += 4
	} else if err != nil {
		return false, errors.Trace(err)
	}
	if missing > 0 {
		if missing < 7 {
			return false, errors.Errorf("found inconsistent records for process %q", id)
		}
		return false, nil
	}
	return true, nil
}

// TODO(ericsnow) Factor most of the below into a processesCollection type.

func (pp procsPersistence) one(id string, doc interface{}) error {
	return errors.Trace(pp.st.One(workloadProcessesC, id, doc))
}

func (pp procsPersistence) all(query, docs interface{}) error {
	return errors.Trace(pp.st.All(workloadProcessesC, query, docs))
}

func (pp procsPersistence) definitionID(id string) string {
	name, _ := process.ParseID(id)
	// The URL will always parse successfully.
	charmURL, _ := charm.ParseURL(pp.charm.Id())
	return fmt.Sprintf("%s#%s", charmGlobalKey(charmURL), name)
}

func (pp procsPersistence) processID(id string) string {
	return fmt.Sprintf("%s#%s", unitGlobalKey(pp.unit.Id()), id)
}

func (pp procsPersistence) launchID(id string) string {
	return pp.processID(id) + "#launch"
}

func (pp procsPersistence) newInsertDefinitionOp(definition charm.Process) txn.Op {
	doc := pp.newProcessDefinitionDoc(definition)
	return txn.Op{
		C:      workloadProcessesC,
		Id:     doc.DocID,
		Assert: txn.DocMissing,
		Insert: doc,
	}
}

func (pp procsPersistence) newInsertProcessOps(info process.Info) []txn.Op {
	var ops []txn.Op
	ops = append(ops, pp.newInsertLaunchOp(info))
	ops = append(ops, pp.newInsertProcOp(info))
	return ops
}

func (pp procsPersistence) newInsertLaunchOp(info process.Info) txn.Op {
	doc := pp.newLaunchDoc(info)
	return txn.Op{
		C:      workloadProcessesC,
		Id:     doc.DocID,
		Assert: txn.DocMissing,
		Insert: doc,
	}
}

func (pp procsPersistence) newInsertProcOp(info process.Info) txn.Op {
	doc := pp.newProcessDoc(info)
	return txn.Op{
		C:      workloadProcessesC,
		Id:     doc.DocID,
		Assert: txn.DocMissing,
		Insert: doc,
	}
}

func (pp procsPersistence) newSetRawStatusOps(id string, status process.RawStatus) []txn.Op {
	id = pp.processID(id)
	return []txn.Op{{
		C:      workloadProcessesC,
		Id:     id,
		Assert: txn.DocExists,
	}, {
		C:      workloadProcessesC,
		Id:     id,
		Assert: isAliveDoc,
		Update: bson.D{{"$set", bson.D{{"pluginstatus", status.Value}}}},
	}}
}

func (pp procsPersistence) newRemoveProcessOps(id string) []txn.Op {
	var ops []txn.Op
	ops = append(ops, pp.newRemoveLaunchOp(id))
	ops = append(ops, pp.newRemoveProcOps(id)...)
	return ops
}

func (pp procsPersistence) newRemoveLaunchOp(id string) txn.Op {
	id = pp.launchID(id)
	return txn.Op{
		C:      workloadProcessesC,
		Id:     id,
		Assert: txn.DocExists,
		Remove: true,
	}
}

func (pp procsPersistence) newRemoveProcOps(id string) []txn.Op {
	id = pp.processID(id)
	return []txn.Op{{
		C:      workloadProcessesC,
		Id:     id,
		Assert: isAliveDoc,
	}, {
		C:      workloadProcessesC,
		Id:     id,
		Assert: txn.DocExists,
		Remove: true,
	}}
}

type processInfoDoc struct {
	definition ProcessDefinitionDoc
	launch     ProcessLaunchDoc
	proc       ProcessDoc
}

func (d processInfoDoc) info() process.Info {
	info := d.proc.info()

	info.Process = d.definition.definition()

	rawStatus := info.Details.Status
	info.Details = d.launch.details()
	info.Details.Status = rawStatus

	return info
}

// ProcessDefinitionDoc is the document for process definitions.
type ProcessDefinitionDoc struct {
	DocID   string `bson:"_id"`
	EnvUUID string `bson:"env-uuid"`

	UnitID string `bson:"unitid"`

	Name        string            `bson:"name"`
	Description string            `bson:"description"`
	Type        string            `bson:"type"`
	TypeOptions map[string]string `bson:"typeoptions"`
	Command     string            `bson:"command"`
	Image       string            `bson:"image"`
	Ports       []string          `bson:"ports"`
	Volumes     []string          `bson:"volumes"`
	EnvVars     map[string]string `bson:"envvars"`
}

func (d ProcessDefinitionDoc) definition() charm.Process {
	ports := make([]charm.ProcessPort, len(d.Ports))
	for i, raw := range d.Ports {
		p := ports[i]
		fmt.Sscanf(raw, "%d:%d:%s", &p.External, &p.Internal, &p.Endpoint)
	}

	volumes := make([]charm.ProcessVolume, len(d.Volumes))
	for i, raw := range d.Volumes {
		v := volumes[i]
		fmt.Sscanf(raw, "%d:%d:%s", &v.ExternalMount, &v.InternalMount, &v.Mode, &v.Name)
	}

	return charm.Process{
		Name:        d.Name,
		Description: d.Description,
		Type:        d.Type,
		TypeOptions: d.TypeOptions,
		Command:     d.Command,
		Image:       d.Image,
		Ports:       ports,
		Volumes:     volumes,
		EnvVars:     d.EnvVars,
	}
}

func (pp procsPersistence) newProcessDefinitionDoc(definition charm.Process) *ProcessDefinitionDoc {
	id := pp.definitionID(definition.Name)

	var ports []string
	for _, p := range definition.Ports {
		// TODO(ericsnow) Ensure p.Endpoint is in state?
		ports = append(ports, fmt.Sprintf("%d:%d:%s", p.External, p.Internal, p.Endpoint))
	}

	var volumes []string
	for _, v := range definition.Volumes {
		// TODO(ericsnow) Ensure v.Name is in state?
		volumes = append(volumes, fmt.Sprintf("%s:%s:%s:%s", v.ExternalMount, v.InternalMount, v.Mode, v.Name))
	}

	return &ProcessDefinitionDoc{
		DocID:  id,
		UnitID: pp.unit.Id(),

		Name:        definition.Name,
		Description: definition.Description,
		Type:        definition.Type,
		TypeOptions: definition.TypeOptions,
		Command:     definition.Command,
		Image:       definition.Image,
		Ports:       ports,
		Volumes:     volumes,
		EnvVars:     definition.EnvVars,
	}
}

func (pp procsPersistence) definition(id string) (*ProcessDefinitionDoc, error) {
	id = pp.definitionID(id)

	var doc ProcessDefinitionDoc
	if err := pp.one(id, &doc); err != nil {
		return nil, errors.Trace(err)
	}
	return &doc, nil
}

func (pp procsPersistence) allDefinitions() (map[string]ProcessDefinitionDoc, error) {
	var docs []ProcessDefinitionDoc
	prefix := pp.definitionID(".*")
	query := bson.M{"$in": []string{"/^" + prefix + "/"}}
	if err := pp.all(query, &docs); err != nil {
		return nil, errors.Trace(err)
	}

	results := make(map[string]ProcessDefinitionDoc)
	for _, doc := range docs {
		parts := strings.Split(doc.DocID, "#")
		id := parts[len(parts)-1]
		results[id] = doc
	}
	return results, nil
}

func (pp procsPersistence) definitions(ids []string) (map[string]ProcessDefinitionDoc, error) {
	fullIDs := make([]string, len(ids))
	idMap := make(map[string]string, len(ids))
	for i, id := range ids {
		fullID := pp.definitionID(id)
		fullIDs[i] = fullID
		name, _ := process.ParseID(id)
		idMap[fullID] = name
	}

	var docs []ProcessDefinitionDoc
	query := bson.M{"$in": fullIDs}
	if err := pp.all(query, &docs); err != nil {
		return nil, errors.Trace(err)
	}

	results := make(map[string]ProcessDefinitionDoc)
	for _, doc := range docs {
		id := idMap[doc.DocID]
		results[id] = doc
	}
	return results, nil
}

// ProcessLaunchDoc is the document for process launch details.
type ProcessLaunchDoc struct {
	DocID   string `bson:"_id"`
	EnvUUID string `bson:"env-uuid"`

	PluginID  string `bson:"pluginid"`
	RawStatus string `bson:"rawstatus"`
}

func (d ProcessLaunchDoc) details() process.Details {
	return process.Details{
		ID: d.PluginID,
		Status: process.RawStatus{
			Value: d.RawStatus,
		},
	}
}

func (pp procsPersistence) newLaunchDoc(info process.Info) *ProcessLaunchDoc {
	id := pp.launchID(info.ID())
	return &ProcessLaunchDoc{
		DocID: id,

		PluginID:  info.Details.ID,
		RawStatus: info.Details.Status.Value,
	}
}

func (pp procsPersistence) launch(id string) (*ProcessLaunchDoc, error) {
	id = pp.launchID(id)

	var doc ProcessLaunchDoc
	if err := pp.one(id, &doc); err != nil {
		return nil, errors.Trace(err)
	}
	return &doc, nil
}

func (pp procsPersistence) allLaunches() (map[string]ProcessLaunchDoc, error) {
	var docs []ProcessLaunchDoc
	prefix := pp.launchID(".*")
	query := bson.M{"$in": []string{"/^" + prefix + "/"}}
	if err := pp.all(query, &docs); err != nil {
		return nil, errors.Trace(err)
	}

	results := make(map[string]ProcessLaunchDoc)
	for _, doc := range docs {
		parts := strings.Split(doc.DocID, "#")
		id := parts[len(parts)-2]
		results[id] = doc
	}
	return results, nil
}

func (pp procsPersistence) launches(ids []string) (map[string]ProcessLaunchDoc, error) {
	fullIDs := make([]string, len(ids))
	idMap := make(map[string]string, len(ids))
	for i, id := range ids {
		fullID := pp.launchID(id)
		fullIDs[i] = fullID
		idMap[fullID] = id
	}

	var docs []ProcessLaunchDoc
	query := bson.M{"$in": fullIDs}
	if err := pp.all(query, &docs); err != nil {
		return nil, errors.Trace(err)
	}

	results := make(map[string]ProcessLaunchDoc)
	for _, doc := range docs {
		id := idMap[doc.DocID]
		results[id] = doc
	}
	return results, nil
}

// ProcessDoc is the top-level document for processes.
type ProcessDoc struct {
	DocID   string `bson:"_id"`
	EnvUUID string `bson:"env-uuid"`

	Life         Life   `bson:"life"`
	Status       string `bson:"status"`
	PluginStatus string `bson:"pluginstatus"`
}

func (d ProcessDoc) info() process.Info {
	var status process.Status
	switch d.Status {
	case "pending":
		status = process.StatusPending
	case "active":
		status = process.StatusActive
	case "failed":
		status = process.StatusFailed
	case "stopped":
		status = process.StatusStopped
	}
	if d.Life != Alive {
		if status != process.StatusFailed && status != process.StatusStopped {
			// TODO(ericsnow) Is this the right place to do this?
			status = process.StatusStopped
		}
	}

	return process.Info{
		Status: status,
		Details: process.Details{
			Status: process.RawStatus{
				Value: d.PluginStatus,
			},
		},
	}
}

func (pp procsPersistence) newProcessDoc(info process.Info) *ProcessDoc {
	id := pp.processID(info.ID())

	var status string
	switch info.Status {
	case process.StatusPending:
		status = "pending"
	case process.StatusActive:
		status = "active"
	case process.StatusFailed:
		status = "failed"
	case process.StatusStopped:
		status = "stopped"
	default:
		// TODO(ericsnow) disallow? don't worry (shouldn't happen)?
		status = "unknown"
	}

	return &ProcessDoc{
		DocID: id,

		Life:         Alive,
		Status:       status,
		PluginStatus: info.Details.Status.Value,
	}
}

func (pp procsPersistence) proc(id string) (*ProcessDoc, error) {
	id = pp.processID(id)

	var doc ProcessDoc
	if err := pp.one(id, &doc); err != nil {
		return nil, errors.Trace(err)
	}
	return &doc, nil
}

func (pp procsPersistence) allProcs() (map[string]ProcessDoc, error) {
	var docs []ProcessDoc
	prefix := pp.processID("[^#]*")
	query := bson.M{"$in": []string{"/^" + prefix + "/"}}
	if err := pp.all(query, &docs); err != nil {
		return nil, errors.Trace(err)
	}

	results := make(map[string]ProcessDoc)
	for _, doc := range docs {
		parts := strings.Split(doc.DocID, "#")
		id := parts[len(parts)-1]
		results[id] = doc
	}
	return results, nil
}

func (pp procsPersistence) procs(ids []string) (map[string]ProcessDoc, error) {
	fullIDs := make([]string, len(ids))
	idMap := make(map[string]string, len(ids))
	for i, id := range ids {
		fullID := pp.processID(id)
		fullIDs[i] = fullID
		idMap[fullID] = id
	}

	var docs []ProcessDoc
	query := bson.M{"$in": fullIDs}
	if err := pp.all(query, &docs); err != nil {
		return nil, errors.Trace(err)
	}

	results := make(map[string]ProcessDoc)
	for _, doc := range docs {
		id := idMap[doc.DocID]
		results[id] = doc
	}
	return results, nil
}
