Lifecycles
==========

In juju, some things have "lifecycles". We sometimes refer to these things as
"entities", but I think that term is becoming overloaded to mean "thing that
can connect to state", ie unit and machine agents (and then presumably, one day,
users). So we don't have a good name for the group, but happily there are ony 4:

  * Machines
  * Units
  * Services
  * Relations

...and there are only 4 possible states for the above things:

  * Alive
  * Dying
  * Dead
  * (removed)

There are two fundamental truths in this system:

  * All such things start existence Alive.
  * No such thing can ever change to an earlier state.

...and just about all else is tricky detail, that is worth examining from a few
different angles. First of all, it's worth considering the things that happen to
each state object separately, insofar as that is possible:

Machines
--------

  * Like everything else, a machine starts out Alive.
  * While it is Alive, principal units can be assigned to it.
  * When no principal units are assigned to it, it can be destroyed with
    `juju destroy-machine`. This will set the machine to Dying, but will
    fail when units are assigned. (Future plans: allow a machine to become
    Dying when it has principal units, so long as they are not Alive. For now
    it's extra complexity with little direct benefit.)
  * Once a machine has been set to Dying, the corresponding Machine Agent (MA)
    is responsible for setting it to Dead. (Future plans: when Dying units are
    assigned, wait for them to become Dead and remove them completely before
    making the machine Dead; not an issue now because the machine can't yet
    become Dying with units assigned.)
  * When the Provisioning Agent (PA) observes that the machine has become Dead,
    it releases the underlying instance back to the provider and removes the
    machine object from state. (Future uncertainty: should the PA provision an
    instance for a Dying machine? At the moment, no, because a Dying machine
    can't have any units in the first place; in the future, er, maybe, because
    those Dying units may be attached to persistent storage and should thus be
    allowed to continue to shut down cleanly as they would usually do. Maybe.)

Units
-----

  * While a principal unit is alive, it can be assigned to machines and can have
    subordinate units added. When subordinate units are added, it is responsible
    for them in exactly the same
  * A unit can become Dying at any time, but may not become Dead while any unit
    subordinate to it exists, or when the unit is in scope for any relation.
    (Future plans: `juju destroy-unit --force`, which will clean up a unit and
    all its subordinates and relations.)
  * A unit can become Dying in one of two ways:
      * `juju destroy-unit`
      * `juju destroy-service` (This happens indirectly: the Unit Agents (UAs)
        for each unit of a service set their corresponding units to Dying when
        they detect service Dying; this is because we try to assume 100k-scale
        and we can't use mgo/txn to do a bulk update of 100k units because that
        makes for a transaction with at least 100k operations and that's just
        crazy.)
  * When a principal unit becomes Dying, all its subordinates must also become
    Dying.
  * When a unit is Dying, its UA is responsible for removing impediments to the
    unit becoming Dead, and then making it so. To do so, the UA must:
      * Depart from all its relations in an orderly fashion.
      * Wait for all its subordinates to become Dead, and remove them from state.
      * Set its unit to Dead.
  * As just noted, when a subordinate unit is Dead, it is removed from state by
    its principal's UA; similarly, when a principal unit is Dead, it is removed
    from state by the MA of the machine to which it is assigned.

Services
--------

  * Unlike units and machines, services have no corresponding agent.
  * In addition, services are never Dead: they can only be Alive or Dying (or
    removed, if you want to consider that a life state).
  * When a service is Alive, units may be added to it, and the service's
    endpoints can be added torelations.
  * A service can become dying at any time, via `juju destroy-service`. This
    causes all the units to become Dying, as discussed above, and will also
    cause all relations in which the service is participating to become Dying.
    (Contentious? I *think* python blocks service removal until relations are
    removed...)
  * If no associated units or relations exist when a service is destroyed, the
    service is removed from state immediately rather than being set to Dying.
  * If no associated relations exist, the service is removed by the MA which
    removes the last unit of that service from state.
  * If no units of the service remain, but its relations still exist, the
    responsibility for removing the service falls to the last UA to leave scope
    for that relation. (Yes, this is a UA for a unit of a totally different
    service.)

Relations
---------

  * A relation, like a service, has no corresponding agent and cannot be Dead.
  * While a relation is Alive, units of services in that relation can enter its
    scope.
  * A relation can become Dying via either `juju destroy-relation` or
    `juju destroy-service`. (Maybe; see services, above.)
  * When a relation is destroyed with no units in scope, it will be removed
    from state immediately rather than being set to Dying.
  * When a relation becomes Dying, the UAs of units that have entered its scope
    are responsible for cleanly departing the relation by running hooks and then
    leaving relation scope.
  * When the last unit leaves the scope of a Dying relation, it must remove the
    relation from state.
  * As noted above, the Dying relation may be the only thing keeping a Dying
    service (different to that of the acting UA) from removal; so, relation
    removal may also imply service removal.

References
----------

OK, that was a bit of a hail of bullets, and the motivations for the above are
perhaps not always clear. To consider it from another angle:

  * Subordinate units reference principal units.
  * Principal units reference machines.
  * All units reference their services.
  * All units reference the relations whose scopes they have joined.
  * All relations reference the services they are part of.

In every case above, where X references Y, the life state of an X may be
sufficient to prevent a change in the life state of a Y; and, conversely, a
life change in an X may be sufficient to cause a life change in a Y. (In only
one case does the reverse hold -- that is, setting a service to Dying will
cause its units' agents to individually set the units to Dying -- and this is
just an implementation detail.)

The following scrawl may help you to visualize the references in play:

        +-----------+       +---------+
    +-->| principal |------>| machine |
    |   +-----------+       +---------+
    |      |     |
    |      |     +--------------+
    |      |                    |
    |      V                    V
    |   +----------+       +---------+
    |   | relation |------>| service |
    |   +----------+       +---------+
    |      A                    A
    |      |                    |
    |      |     +--------------+
    |      |     |
    |   +-------------+
    +---| subordinate |
        +-------------+

...but is important to remember that it's only one view of the relationships
involved, and that the user-centric view is quite different; from a user's
perspective the influences appear to travel in the opposite direction:

  * (destroying a machine "would" destroy its principals but that's disallowed)
  * destroying a principal destroys all its subordinates
  * (destroying a subordinate directly is impossible)
  * destroying a service destroys all its units and relations
  * destroying a container relation destroys all subordinates in the relation
  * (destroying a global relation destroys nothing else)

...and it takes a combination of these viewpoints to understand the detailed
interactions laid out above.

Agents
------

It may also be instructive to consider the responsibilities of the unit and
machine agents. The unit agent is responsible for:

  * detecting its service's Dying state, and setting its own Dying state.
  * detecting its own Dying state, and:
      * leaving relation scopes
      * possibly removing those relations
      * possibly removing some of those relations' services
      * waiting for its subordinates' Dead states and
          * removing the subordinates
          * possibly removing their services
      * finally setting its own Dead state

The machine agent, meanwhile, is responsible for:

  * detecting its principals' Dead states and:
      * removing the principals
      * possibly removing their services
  * detecting its machine's Dying state, and setting it to Dead.

Finally, the provisioning agent is responsible for:

  * detecting machines' Dead states, and removing the machines.

(Oh: it shoud be noted explicitly that the PA is responsible for provisioning
Alive machines, that an MA is responsible for deploying Alive principals, that
a principal UA is responsible for creating and deploying its Alive subordinates,
and that all UAs are responsible for entering relevant relation scopes; but that
side is easy, and the what-do-we-do-with-a-Dying-object problem STM to have the
same tradeoffs regardless of object: the problem is still, and always, about
how we shoud treat Dying units backed by persistent storage, and the answer
remains easy... for now.)

Implementation
--------------

We use the mgo/txn package for easy multi-document transactions against MongoDB.
Without this, it would be very difficult to enforce the various conditions
described above (consider, for example, the race between one client assigning a
new principal to a machine that another client is trying to destroy). However,
even with mgo/txn doing an awful lot of heavy lifting, actually landing a
consistent transaction occasionally demands a somewhat taxing level of attention
to detail.

At the moment, the only type whose lifecycle has been implemented approximately
correctly is relation... and even that's incomplete, because RelationUnit's
LeaveScope method fails to take into account the possibility that it might be
responsible for destroying a service as well as just a relation. But, I guess,
we haven't started looking at service desctruction yet, so this is maybe not so
bad.

So -- IMO, none of this has yet been implemented to an adequate standard, and
we're not short of detailed work to do. I'm currently focused on subordinates,
which will demand correct implementations of:

  * relation destruction (done)
  * service destruction (not started)
  * unit destruction (not started)

...and if we're doing all those we really should do machine destruction too,
especially considering it'll be easiest, but I'm not even going to think about
that until i've dealt with the rest.

Implementation issues
---------------------

As mentioned, we save ourselves some hassle by restricting machines to become
Dying only when they have no units (rather than when none of their units are
Alive). Fixing this will probably be trivial (we have to solve almost exactly
the same problem for subordinate units wrt their principal), but since we don't
*have* to worry about it yet I'm ignoring it.

But there's a trickier one: as you will no doubt have observed, the unit is
mired deep in dependencies, and a non-functioning unit agent can potentially
paralyse whole chunks of the system [0]. So, we decided a while ago that we should
support forcible unit destruction: that it should be possible to set a unit to
Dead directly.

However, the number of interactions between units and other objects is a little
bit daunting. In the worst case, forcibly destroying a unit and keeping state
consistent may require:

  * that the unit leave several relation scopes
  * that the unit remove several relations it had been in scope of
  * that the unit remove some services on the other end of removed relations

...*and*:

  * that all the same things happen for all the unit's subordinates.

To take a pessimistic view of the matter, "just" setting a unit to Dead may
require hundreds of txn operations in a pathological case. However, none of
the alternatives fill me with great joy; I am starting to feel that a big
ugly bottleneck txn (specifically to deal with known-pathological cases) may
in fact be the most reliable and comprehensible way to express the desired
state change. More discussions on this topic will most assuredly come to pass.

-----

[0] Heh. Frankly, so can a paralysed MA. `juju destroy-machine --force`..? If unit
force destruction seemed complex, the machine case is even worse because machines
can (in theory, if not currently in practice) have several principal units. No, I
haven't figured out how to deal with a paralysed PA either...
