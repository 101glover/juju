// Copyright 2016 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

// +build !windows

package network_test

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/juju/testing"
	jc "github.com/juju/testing/checkers"
	gc "gopkg.in/check.v1"

	"github.com/juju/juju/network"
)

type UtilsSuite struct {
	testing.IsolationSuite
}

var _ = gc.Suite(&UtilsSuite{})

func (*UtilsSuite) TestParseResolvConfEmptyOrMissingPath(c *gc.C) {
	emptyPath := ""
	missingPath := filepath.Join(c.MkDir(), "missing")

	for _, path := range []string{emptyPath, missingPath} {
		result, err := network.ParseResolvConf(path)
		c.Check(err, jc.ErrorIsNil)
		c.Check(result, gc.IsNil)
	}
}

func (*UtilsSuite) TestParseResolvConfNotReadablePath(c *gc.C) {
	fakeResolvConf := makeResolvConf(c, "#empty", 0000)

	result, err := network.ParseResolvConf(fakeResolvConf)
	expected := fmt.Sprintf("open %s: permission denied", fakeResolvConf)
	c.Check(err, gc.ErrorMatches, expected)
	c.Check(result, gc.IsNil)
}

func makeResolvConf(c *gc.C, content string, perms os.FileMode) string {
	fakeResolvConf := filepath.Join(c.MkDir(), "fake")
	err := ioutil.WriteFile(fakeResolvConf, []byte(content), perms)
	c.Check(err, jc.ErrorIsNil)
	return fakeResolvConf
}

func (*UtilsSuite) TestParseResolvConfEmptyFile(c *gc.C) {
	fakeResolvConf := makeResolvConf(c, "", 0644)

	result, err := network.ParseResolvConf(fakeResolvConf)
	c.Check(err, jc.ErrorIsNil)
	c.Check(result, jc.DeepEquals, &network.DNSConfig{})
}

func (*UtilsSuite) TestParseResolvConfSuccess(c *gc.C) {
	const exampleResolvConf = `
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
 nameserver       127.0.1.1
  # empty lines and comments ignored
nameserver 8.8.8.8 # comments ignored
  search   example.org
nameserver 2001:db8::1/64
search example.com # comments ignored
search foo
anything-else ignored
`
	fakeResolvConf := makeResolvConf(c, exampleResolvConf, 0644)

	expected := &network.DNSConfig{
		Nameservers: network.NewAddresses(
			"127.0.1.1",
			"2001:db8::1/64",
			"8.8.8.8",
		),
		SearchDomains: []string{
			"example.com",
			"example.org",
			"foo",
		},
	}

	result, err := network.ParseResolvConf(fakeResolvConf)
	c.Check(err, jc.ErrorIsNil)
	c.Check(result, jc.DeepEquals, expected)
}
