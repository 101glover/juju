package vmware

import (
	"io/ioutil"
	"net/http"
	"path"

	"github.com/juju/errors"
	"github.com/vmware/govmomi"
	"github.com/vmware/govmomi/find"
	"github.com/vmware/govmomi/vim25/methods"
	"github.com/vmware/govmomi/vim25/mo"
	"github.com/vmware/govmomi/vim25/progress"
	"github.com/vmware/govmomi/vim25/types"

	"github.com/juju/juju/juju/osenv"
)

const (
	metadataKeyIsState = "juju-is-state"
)

type client struct {
	connection   *govmomi.Client
	datacenter   *govmomi.Datacenter
	datastore    *govmomi.Datastore
	resourcePool *govmomi.ResourcePool
}

func newClient(ecfg *environConfig) (*client, error) {
	url, err := ecfg.url()
	if err != nil {
		return nil, err
	}
	connection, err := govmomi.NewClient(*url, false)
	if err != nil {
		return nil, err
	}

	finder := find.NewFinder(connection, true)
	datacenter, err := finder.Datacenter(ecfg.datacenter())
	if err != nil {
		return nil, err
	}
	datastore, err := finder.Datastore(ecfg.datastore())
	if err != nil {
		return nil, err
	}
	resourcePool, err := finder.ResourcePool(ecfg.resourcePool())
	if err != nil {
		return nil, err
	}
	return &client{
		connection:   connection,
		datacenter:   datacenter,
		datastore:    datastore,
		resourcePool: resourcePool,
	}, nil
}

type ovfFileItem struct {
	url  *url.URL
	item types.OvfFileItem
	ch   chan progress.Report
}

func (o ovfFileItem) Sink() chan<- progress.Report {
	return o.ch
}

func (c *client) CreateInstance(machineID string, hwc *instance.HardwareCharacteristics, img *ImageMetadata, diskSize int64, userData []byte) (*mo.VirtualMachine, error) {
	vm := govmomi.NewVirtualMachine(c.connection, info.Result.(types.ManagedObjectReference))

	devices, err := vm.Device()
	if err != nil {
		return nil, err
	}

	task, err = c.extendVirtualDiskTask(c.datastore.Path(spec.Name), diskSize)
	if err != nil {
		return nil, err
	}
	info, err = task.WaitForResult(nil)
	if err != nil {
		return nil, err
	}

	task, err = vm.PowerOn()
	if err != nil {
		return nil, err
	}
	var res mo.VirtualMachine
	err = c.connection.Properties(vm.Reference(), []string{""}, &res)
	if err != nil {
		return nil, err
	}
	return &res, nil
}

func (c *client) importOvf(hwc *instance.HardwareCharacteristicsi, mg *ImageMetadata) {
	folders, err := c.datacenter.Folders()
	if err != nil {
		return nil, err
	}

	ovf, err := c.downloadOvf(img)
	if err != nil {
		return nil, err
	}

	cisp := types.OvfCreateImportSpecParams{
		EntityName:      config.Name,
		PropertyMapping: []types.KeyValue{},
	}

	spec, err := c.OvfManager().CreateImportSpec(string(ovf), c.resourcePool, c.datastore, cisp)
	if err != nil {
		return err
	}

	if spec.Error != nil {
		return errors.New(spec.Error[0].LocalizedMessage)
	}

	instSpec := types.VirtualMachineConfigSpec{
		Name:     machineID,
		Files:    &types.VirtualMachineFileInfo{VmPathName: fmt.Sprintf("[%s]", env.client.datastore.Name())},
		NumCPUs:  int(cpuCores),
		MemoryMB: int64(mem),
		CpuAllocation: &types.ResourceAllocationInfo{
			Limit:       int64(cpuPower),
			Reservation: int64(cpuPower),
		},
	}
	s := &spec.ImportSpec.(*types.VirtualMachineImportSpec).ConfigSpec
	for _, d := range s.DeviceChange {
		n := &d.GetVirtualDeviceConfigSpec().Device.GetVirtualDevice().UnitNumber
		if *n == 0 {
			*n = -1
		}
	}

	lease, err := c.resourcePool.ImportVApp(spec.ImportSpec, folders.VmFolder, nil)
	if err != nil {
		return err
	}

	info, err := lease.Wait()
	if err != nil {
		return err
	}
	items = make([]ovfFileItem, len(spec.FileItem))
	for _, device := range info.DeviceUrl {
		for _, item := range spec.FileItem {
			if device.ImportKey != item.DeviceId {
				continue
			}

			u, err := c.Client.ParseURL(device.Url)
			if err != nil {
				return err
			}

			i := ovfFileItem{
				url:  u,
				item: item,
				ch:   make(chan progress.Report),
			}
			items = append(items, i)
		}
	}

	u := newLeaseUpdater(cmd.Client, lease, items)
	defer u.Done()

	for _, i := range items {
		err = cmd.Upload(lease, i)
		if err != nil {
			return err
		}
	}
	lease.HttpNfcLeaseComplete()
}

func (c *client) Upload(ofi ovfFileItem) error {
	item := ofi.item
	file := item.Path

	f, size, err := cmd.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()

	opts := soap.Upload{
		ContentLength: size,
		Progress:      progress.Tee(ofi, logger),
	}

	// Non-disk files (such as .iso) use the PUT method.
	// Overwrite: t header is also required in this case (ovftool does the same)
	if item.Create {
		opts.Method = "PUT"
		opts.Headers = map[string]string{
			"Overwrite": "t",
		}
	}
	return cmd.Client.Client.Upload(f, ofi.url, &opts)
}

func (c *client) downloadOvf(img *ImageMetadata) (string, error) {
	resp, err := http.Get(img.OvfPath)
	if resp.Status != 200 {
		return "", errors.Errorf("Can't download ovf file from url: %v", img.OvfPath)
	}
	defer resp.Body.Close()
	bytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return errors.Tracef(err)
	}
	return string(bytes), nil
}

func (c *client) downloadImg(img ImageMetadata) (string, error) {
	path := path.Join(osenv.JujuHome(), "images", path.Base(img.ImagePath))

	if err := os.MkdirAll(path, 0755); err != nil {
		return nil, errors.Annotatef("create images storage (MkdirAll)", err)
	}
	if _, err := os.Stat(path); err == nil {
		return path, nil
	}
	resp, err := http.Get(img.OvfPath)
	if resp.Status != 200 {
		return "", errors.Errorf("Can't download ovf file from url: %v", img.OvfPath)
	}

	resp, err := http.Get(img.OvfPath)
	defer resp.Body.Close()
	_, err := io.Copy(out, resp.Body)
	bytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return errors.Tracef(err)
	}
	return string(bytes), nil
}

func (c *client) extendVirtualDiskTask(name string, sizeMb int64) (*govmomi.Task, error) {
	datacenter := c.datacenter.Reference()
	req := types.ExtendVirtualDisk_Task{
		This:          *c.connection.ServiceContent.VirtualDiskManager,
		Name:          name,
		Datacenter:    &datacenter,
		NewCapacityKb: sizeMb * 1024,
	}

	res, err := methods.ExtendVirtualDisk_Task(c.connection, &req)
	if err != nil {
		return nil, err
	}

	return govmomi.NewTask(c.connection, res.Returnval), nil
}

func (c *client) generateUserDataIso(userData []byte) (path string, err error) {
	return "", nil
}

func (c *client) RemoveInstances(prefix string, instances ...string) error {
	return errors.NotImplementedf("")
}

func (c *client) Instances(prefix string) ([]mo.VirtualMachine, error) {
	return nil, errors.NotImplementedf("")
}

func (c *client) Refresh(v *mo.VirtualMachine) error {
	return errors.NotImplementedf("")
}
