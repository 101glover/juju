// Copyright 2016 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package persistence

import (
	"github.com/juju/errors"
	jujutxn "github.com/juju/txn"
	"gopkg.in/mgo.v2/bson"
	"gopkg.in/mgo.v2/txn"

	"github.com/juju/juju/payload"
)

type payloadsTxnRunner interface {
	// Run runs the transaction generated by the provided factory
	// function. It may be retried several times.
	Run(transactions jujutxn.TransactionSource) error
}

type payloadsTransaction interface {
	newOps(pq payloadsQueries) ([]txn.Op, error)
	retryOps(pq payloadsQueries) ([]txn.Op, error)
}

type payloadsTransactions struct {
	q      payloadsQueries
	runner payloadsTxnRunner
}

func (pt payloadsTransactions) run(ptxn payloadsTransaction) error {
	buildTxn := pt.newTxnSource(ptxn)
	if err := pt.runner.Run(buildTxn); err != nil {
		return errors.Trace(err)
	}
	return nil
}

func (pt payloadsTransactions) newTxnSource(ptxn payloadsTransaction) jujutxn.TransactionSource {
	return func(attempt int) ([]txn.Op, error) {
		if attempt == 0 {
			ops, err := ptxn.newOps(pt.q)
			if err != nil {
				return nil, err
			}
			return ops, nil
		} else {
			ops, err := ptxn.retryOps(pt.q)
			if err != nil {
				return nil, err
			}
			// Probably a transient error, so try again.
			return ops, nil
		}
	}
}

type insertPayloadTxn struct {
	unit string
	stID string
	p    payload.FullPayloadInfo
}

func (txn insertPayloadTxn) newOps(pq payloadsQueries) ([]txn.Op, error) {
	_, err := pq.payloadByStateID(txn.unit, txn.stID)
	if err == nil {
		return nil, errors.Annotatef(payload.ErrAlreadyExists, "(ID %q)", txn.stID)
	}
	if !errors.IsNotFound(err) {
		return nil, errors.Trace(err)
	}
	// There is a *slight* race here...

	ops := newInsertPayloadOps(txn.stID, txn.p)
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	return ops, nil
}

func (txn insertPayloadTxn) retryOps(pq payloadsQueries) ([]txn.Op, error) {
	_, err := pq.payloadByName(txn.unit, txn.p.Name)
	if err == nil {
		return nil, errors.Annotatef(payload.ErrAlreadyExists, "(%s)", txn.p.FullID())
	}
	if !errors.IsNotFound(err) {
		return nil, errors.Trace(err)
	}

	ops := newInsertPayloadOps(txn.stID, txn.p)
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	return ops, nil
}

type setPayloadStatusTxn struct {
	unit   string
	stID   string
	status string
}

func (txn setPayloadStatusTxn) newOps(pq payloadsQueries) ([]txn.Op, error) {
	doc, err := pq.payloadByStateID(txn.unit, txn.stID)
	if errors.IsNotFound(err) {
		return nil, errors.Annotatef(payload.ErrNotFound, "(%s)", txn.stID)
	}
	if err != nil {
		return nil, errors.Trace(err)
	}
	name := doc.Name

	ops := newSetRawPayloadStatusOps(txn.unit, name, txn.stID, txn.status)
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	return ops, nil
}

func (txn setPayloadStatusTxn) retryOps(pq payloadsQueries) ([]txn.Op, error) {
	return txn.newOps(pq)
}

type removePayloadTxn struct {
	unit string
	stID string
}

func (txn removePayloadTxn) newOps(pq payloadsQueries) ([]txn.Op, error) {
	doc, err := pq.payloadByStateID(txn.unit, txn.stID)
	if errors.IsNotFound(err) {
		// Must have already beeen removed!
		return nil, jujutxn.ErrNoOperations
	}
	if err != nil {
		return nil, errors.Trace(err)
	}
	name := doc.Name

	ops := newRemovePayloadOps(txn.unit, name, txn.stID)
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	return ops, nil
}

func (txn removePayloadTxn) retryOps(pq payloadsQueries) ([]txn.Op, error) {
	return txn.newOps(pq)
}

func newInsertPayloadOps(id string, p payload.FullPayloadInfo) []txn.Op {
	// We must also ensure that there isn't any collision on the
	// state-provided ID. However, that isn't something we can do in
	// a transaction.
	doc := newPayloadDoc(id, p)
	return []txn.Op{{
		C:      payloadsC,
		Id:     doc.DocID,
		Assert: txn.DocMissing,
		Insert: doc,
	}}
}

func newSetRawPayloadStatusOps(unit, name, stID, status string) []txn.Op {
	id := payloadID(unit, name)
	updates := bson.D{
		{"state", status},
	}
	return []txn.Op{{
		C:      payloadsC,
		Id:     id,
		Assert: txn.DocExists,
		Update: bson.D{{"$set", updates}},
	}, {
		C:      payloadsC,
		Id:     id,
		Assert: bson.D{{"state-id", stID}},
	}}
}

func newRemovePayloadOps(unit, name, stID string) []txn.Op {
	id := payloadID(unit, name)
	return []txn.Op{{
		C:      payloadsC,
		Id:     id,
		Assert: txn.DocExists,
		Remove: true,
	}, {
		C:      payloadsC,
		Id:     id,
		Assert: bson.D{{"state-id", stID}},
	}}
}
