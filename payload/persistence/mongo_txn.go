// Copyright 2016 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package persistence

import (
	"github.com/juju/errors"
	jujutxn "github.com/juju/txn"
	"gopkg.in/mgo.v2/bson"
	"gopkg.in/mgo.v2/txn"

	"github.com/juju/juju/payload"
)

type payloadsTxnRunner interface {
	// Run runs the transaction generated by the provided factory
	// function. It may be retried several times.
	Run(transactions jujutxn.TransactionSource) error
}

type payloadsTransaction interface {
	checkAsserts(pq payloadsQueries) error
	ops() []txn.Op
}

type payloadsTransactions struct {
	queries payloadsQueries
	runner  payloadsTxnRunner
}

func (pt payloadsTransactions) run(ptxn payloadsTransaction) error {
	buildTxn := pt.newTxnSource(ptxn)
	if err := pt.runner.Run(buildTxn); err != nil {
		return errors.Trace(err)
	}
	return nil
}

func (pt payloadsTransactions) newTxnSource(ptxn payloadsTransaction) jujutxn.TransactionSource {
	return func(attempt int) ([]txn.Op, error) {
		// We always check the asserts manually before returning ops.
		if err := ptxn.checkAsserts(pt.queries); err != nil {
			return nil, errors.Trace(err)
		}
		// If the asserts check out then it was probably a transient
		// error, so try again.

		return ptxn.ops(), nil
	}
}

type insertPayloadTxn struct {
	unit    string
	stID    string
	payload payload.FullPayloadInfo
}

func (itxn insertPayloadTxn) checkAsserts(pq payloadsQueries) error {
	_, err := pq.payloadByName(itxn.unit, itxn.payload.Name)
	if err == nil {
		return errors.Annotatef(payload.ErrAlreadyExists, "(%s)", itxn.payload.FullID())
	}
	if !errors.IsNotFound(err) {
		return errors.Trace(err)
	}

	_, err = pq.payloadByStateID(itxn.unit, itxn.stID)
	if err == nil {
		return errors.Annotatef(payload.ErrAlreadyExists, "(ID %q)", itxn.stID)
	}
	if !errors.IsNotFound(err) {
		return errors.Trace(err)
	}

	return nil
}

func (itxn insertPayloadTxn) ops() []txn.Op {
	// We must also ensure that there isn't any collision on the
	// state-provided ID. However, that isn't something we can do in
	// a transaction.

	doc := newPayloadDoc(itxn.stID, itxn.payload)
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	return []txn.Op{{
		C:      payloadsC,
		Id:     doc.DocID,
		Assert: txn.DocMissing,
		Insert: doc,
	}}
}

type setPayloadStatusTxn struct {
	unit   string
	stID   string
	name   string
	status string
}

func (stxn *setPayloadStatusTxn) checkAsserts(pq payloadsQueries) error {
	doc, err := pq.payloadByStateID(stxn.unit, stxn.stID)
	if errors.IsNotFound(err) {
		return errors.Annotatef(payload.ErrNotFound, "(%s)", stxn.stID)
	}
	if err != nil {
		return errors.Trace(err)
	}
	stxn.name = doc.Name

	return nil
}

func (stxn setPayloadStatusTxn) ops() []txn.Op {
	id := payloadID(stxn.unit, stxn.name)
	updates := bson.D{
		{"state", stxn.status},
	}
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	return []txn.Op{{
		C:      payloadsC,
		Id:     id,
		Assert: txn.DocExists,
		Update: bson.D{{"$set", updates}},
	}, {
		C:      payloadsC,
		Id:     id,
		Assert: bson.D{{"state-id", stxn.stID}},
	}}
}

type removePayloadTxn struct {
	unit string
	stID string
	name string
}

func (rtxn *removePayloadTxn) checkAsserts(pq payloadsQueries) error {
	doc, err := pq.payloadByStateID(rtxn.unit, rtxn.stID)
	if errors.IsNotFound(err) {
		// Must have already beeen removed!
		return jujutxn.ErrNoOperations
	}
	if err != nil {
		return errors.Trace(err)
	}
	rtxn.name = doc.Name

	return nil
}

func (rtxn removePayloadTxn) ops() []txn.Op {
	id := payloadID(rtxn.unit, rtxn.name)
	// TODO(ericsnow) Add unitPersistence.newEnsureAliveOp(pp.unit)?
	return []txn.Op{{
		C:      payloadsC,
		Id:     id,
		Assert: txn.DocExists,
		Remove: true,
	}, {
		C:      payloadsC,
		Id:     id,
		Assert: bson.D{{"state-id", rtxn.stID}},
	}}
}
